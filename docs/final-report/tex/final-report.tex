\documentclass{article}
% \documentclass[twocolumn]{article}

% Load basic packages
\usepackage{balance}  % to better equalize the last page
% \usepackage{graphics} % for EPS, load graphicx instead 
\usepackage{txfonts}
\usepackage{times}    % comment if you want LaTeX's default font
\usepackage{color}
\usepackage{textcomp}
\usepackage{booktabs}
%\usepackage{ccicons}
\usepackage{todonotes}
\usepackage{float}
\usepackage{url}  
\usepackage{titling}	% allows you to move title up the page
\usepackage[
  pdftex,
  % colorlinks=true,
  pdfborder={0 0 0},
  linkcolor=red
]{hyperref}
\usepackage{xcolor} 
\usepackage{multicol}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{capt-of}

% for code blocks
\usepackage{listings}
\usepackage{listings-golang} % import this package after listings

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
% \definecolor{darkgray}{rgb}{.4,.4,.4}
% \definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{TypeScript}{
  keywords={undefined, boolean, number, string, break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, enum, interface, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{purple}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  sensitive=true
}

\lstset{
   language=TypeScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
\renewcommand{\lstlistingname}{Code Snipped}
%%%%%%%%%

% Foot note line size
\renewcommand{\footnoterule}{%
  \kern -3pt
  \hrule width \textwidth height 0.5pt
  \kern 2pt
}

% font  sizes
\usepackage{sectsty}			% set font sizes			
\sectionfont{\Large}			% (assumes default font size 10pt)
\subsectionfont{\large}
% \subsubsectionfont{\large}
\subsubsectionfont{\normalsize}
\paragraphfont{\normalsize}

% positioning
\setlength{\parindent}{0em}		% remove indent for new paragraph
\setlength{\parskip}{1em}		% space above paragraph
\setlength{\columnsep}{2em}		% distance between columns
\setlength{\droptitle}{-10em}

% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\bf\ttfamily}}}
\makeatother
\urlstyle{leo}


% making TOC and LOF smaller
% \AtBeginDocument{
  % \addtocontents{toc}{\tiny}
  % \addtocontents{lof}{\tiny}
% }

% \usepackage{xpatch}
% \makeatletter
% \xpatchcmd{\tableofcontents}{\contentsname \@mkboth}{\small\contentsname \@mkboth}{}{}
% \xpatchcmd{\listoffigures}{\chapter *{\listfigurename }}{\chapter *{\small\listfigurename }}{}{}
% \makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This is a constant to space out the section titles from their body
\newcommand{\vspaceconst}{-2ex}

% For notes
\newcommand{\TODO}{\textbf{\textit{\textcolor{red}{TODO:}}} }
\newcommand{\NOTE}{\textbf{\textit{\textcolor{red}{NOTE:}}} }

% For my sanity
\newcommand{\tpt}{\textit{`tracking point type'}}
\newcommand{\tpts}{\textit{`tracking point types'}}
\newcommand{\tp}{\textit{`tracking point'}}
\newcommand{\tps}{\textit{`tracking points'}}
\newcommand{\tg}{\textit{`tracking group'}}
\newcommand{\tgs}{\textit{`tracking groups'}}

\title{Honours Project Report\\Fitness Logger with Micro-services}
\author{Dumitru Vulpe\\BSc (Hons) Applied Computing\\Supervised by Andrew Colby}
\date{May 2021}

\begin{document}

\maketitle

\vspace*{\fill/2}
\begin{abstract} 

This project is a tool to let people be able to log and track workouts overtime easily from their phone in a flexible yet complete way. The initial purpose was to make a phone application which can be used across different disciplines of sport and with different workout types. This would be done by breaking up the data in different manageable units so that the use can create their own workflow for logging workouts.

However, the main appeal of this project is the backend implementation. This is because as a part of the architecture design process, it was decided that a micro-services structure would be followed. Where the backend would be split up into multiple applications which would talk to each other where needed. This was chosen for a multitude of reasons, including as a learning experience for this kind of backend architecture.

\end{abstract}
\vspace*{\fill}

\newpage
\tableofcontents 
\listoffigures
\newpage

\begin{multicols}{2}
\section{Introduction}
\vspace{\vspaceconst}

\TODO~Need to come back after I'm done with the entire report to summarise it\\
\NOTE~Started this section first but then realised it would be easier to complete after finishing the report\\

This project is split into two main objectives; first objective was to to be a learning experience of creating a full stack application beginning to end and more importantly to get into micro services backend development. The second objective was to attempt to solve a problem which exists in the fitness industry by creating an application which would be useful to a different range of people and potentially taking this product to the market.


\subsection{Why micro services}
\vspace{\vspaceconst}

The basic principle of micro services as supposed to a monolith, is to split up the backend application into multiple smaller application. For example, in theory, a service such as Amazon, could have a separate micro service for the cart function, one for listings, one more user account management, one for payment and more.
Micro services architectures are becoming more and more relevant simply because the industry is getting becoming more and more complex. And as size, complexity and user bases increase, so does the need for well scaled web applications. Micro services type architectures are simply one way to cleanly and easily scale web applications. So because of industry relevance and my personal enthusiasm, it was decided that this project's backend would also follow this architecture. 

\subsection{Creating a potential product}
\vspace{\vspaceconst}

Creating a folly fledged product out of this project was never my main idea. However, in my personal opinion, my planned solution for the problem has enough potential that could work as a product in the market. And as long as the application works as intended, there are multiple potential monetisation routes which could be taken, such as extra features behind a subscription or just a flat rate at purchase.

\subsubsection{The problem}
\vspace{\vspaceconst}

From personal past experience I have not found a simple, fuss free, yet flexible application for logging workout sessions and related notes for said session. The applications which I have tried so far are either made for a specific workout programs or are not complete, buggy or just do not have enough flexibility in the type of logging you can achieve. It often feels like a fight to be able to use such an app.\\
In the fitness world there can be a lot of different types of workouts, exercises, exercise variations, and ways to do said exercises. Because of this, coaches, personal trainers and everyday people usually would stick to using a notepad and paper  simply because there are no arbitrary restrains on what you can log.\\
Typically a notepad and pen is not a bad solution and usually preferable to most applications, however, there are certain drawbacks to this approach. One practical drawback is highlighted when working out in a commercial gym, walking around the gym using different equipment and carrying everything one might need including the notebook and pen combo can be quite cumbersome, same goes for actually noting down the data in the notebook. When it comes to looking back on previous workouts it can also be quite cumbersome, especially when you are in the middle of a workout and do not want to loose the tempo.\\

\subsubsection{My planned solution}
\vspace{\vspaceconst}

The idea was that the system would be designed around the data structure which would be saved by the user. This data structure would be made as simple as possible while still allowing all the common basic exercise options (such as repetitions, resistance values, sets etc) but also others (such as the option to just write a single value). Furthermore, the system would allow the user to create their own exercise types which they would then use when logging a workout. 

When using the application the user would first create a custom `type'. This type would usually be an exercise, however, it it not constrained to be one. For example, one type would be `exercise x' and another type could be `caffeine intake' for tracking the intake of caffeine over different workouts. Then, the 

\section{Background}
\vspace{\vspaceconst}

\TODO~talk about common problems that arise in companies and how using micro services can help solve those problems. See if u can find some sources

\subsection{Architecture design}
\TODO~see if u can find a citation for the "popular questions to be answered" 

A lot of time during this project was allocated to research of the backend architecture design, specifically relating to micro services. And when it comes to it, there is not just one or few generally accepted standards and patterns that projects adopt. This is simply because each and every system architect needs to answer a lot of questions about it will all be built.
 For instance, the questions about how the different services should be split, some say it should be split by the feature, some say by the individual data element, by endpoint and more. Another popular questions is how the services diagram should look like, one of the popular answers are to have a separate authentication service to provide authentication for the application and proxy the requests to all the other services. However, regardless of the question, there are a lot of different ways solutions to all of these questions that need to be answered when starting a project using micro services and all of them come with their own advantages and disadvantages. 

\subsubsection{Helpful technologies}

  When creating micro services systems, there are a lot of technologies which could and would be used to make the development of these services easier. Probably one of the first pieces of technologies to ease the development and deployment of micro services a lot easier was containers. Containers allow you to package applications with all of the needed dependencies and environments, they virtualise the user-land applications and share the hosts kernel, and on a Linux system that means that containers can virtually run anywhere. Furthermore, we have also have container management and orchestration solutions such as Docker\cite{Docker}, docker-compose\cite{Docker}, Kubernetes\cite{k8s} and more. These help with running the actual containers, and in the case of Kubernetes, it also allows us to easily define configurations and scale the containers either on a definition or on demand. Scaling here would be done by running more instances of that container across a cluster of machines running the Kubernetes and load balancing the traffic amongst them. This is known as horizontal scaling.\\
Micro services would often also need to talk to each other and as before, depending on requirements and design, there are different ways to do it. Overall there are two options many systems using both synchronous and asynchronous calls. Synchronous calls are usually straight forward and done over HTTP and the only thing that would need to be solved is proper authentication. Asynchronous calls are often made with either RPC calls (commonly gRPC\cite{grpc} would be used) or a message/event bus system such as Kafka\cite{kafka}.\\
  Another great series of helpful technologies are service meshes, they provide great insight into your cluster of micro services. It is a dedicated infrastructure layer that all the different micro services would proxy their communication in-between. This can provide a multitude of benefits including communication observability, call chain traceability, secure connections and more. Examples of such services are Linkerd\cite{linkerd} and Istio\cite{istio}. If this project would be using Kubernetes, a service mesh would definitely be very useful and worth wile to integrate into the system.

\subsection{Market} % Competitors apps
\vspace{\vspaceconst}

\TODO~Need to find and list of competitor apps\\
- the one I have tried was zero to hero\\

\section{Specification}
\vspace{\vspaceconst}

\subsection{Micro services}
\vspace{\vspaceconst}

The proposed project is tackling two main problems, one being a whole set conceptual problem which are very common with increased project sizes, weather that is in terms of complexity, code base, team size or general scope of the project. So it is generally welcome to try and apprehend for these problems ahead of time by careful planning and designing of the system. In this case, the careful planning and designing would be done on the backend architecture. Here, using micro services would solve a lot of problems, both technical and business problems.

\subsubsection{Business \& general project management problems}
\vspace{\vspaceconst}

When a project grows in size to the point where there is a need for multiple teams it can become quite challenging to have all of the teams work on the same code base. Different tactics such as smart management of source management system could help with this issue. One such example would be to have different development branches for each team, however, this could introduce more problems such as needing to re-base the branch mid development. Here a much better way would be to simply have the teams work on different codebases, each making up a micro service. Depending on how the teams are organised, or on how the features are broken down in each micro service, each team would be solely responsible of one or more micro services, making them the de facto experts on that specific micro a service and its inner workings.\\
What about when new individuals or teams enter the workforce? There is usually a fair amount of time taken just simply getting acclimated with the codebase and the whole product. Now, this would be true weather the project is or is not following a micro services architecture, however, if the project is just a monolith, usually the individual or team would need to get familiar with the while codebase. This would not need to be true in case of micro services.\\
With micro services the individual or team would just need to look at the API documentation of the project, then only get accustomed with the micro service(s) that they would be working on. This way collaboration between teams also will become easier due to each team maintaining their own small codebases, and documentation for how to interact with their services.\\

\subsubsection{The technical aspect}
\vspace{\vspaceconst}

Originally projects would just be one monolithic application and if we needed more performance we would optimise the code and add more power through better server hardware (or add more resources to the virtual machine or container if it was applicable). This is called vertical scaling. However, what happens when we need even more scaling? There can only be so much power we can add to one single server and only so much optimisation we can do to a codebase. Projects then started to scale their applications horizontally by deploying more instances of it, then adding some form of a load balancer which would balance the requests across all of their different deployments. These deployments could be individual computers, running the application directly on bare metal\footnote{Bare metal meaning that there is no other layer of management such as virtualisation or containerization and is running directly on the host OS.}. This, however, could be quite inefficient because it would scale the whole application and this might not be needed.\\
For example, assume \textit{Application x} has a user profile endpoint which is just a simple CRUD\footnote{Referring to data operations of Create Read Update Delete.} operation and a pictures endpoint which is responsible for handling picture uploads, picture compression, storage, serving, etc. The part which will need the most processing power will be the pictures endpoint, but when vertically scaling a monolith, all of the endpoints get deployed again regardless if they needed the extra resources or not. This in principle is wasted resources and by extension wasted budget for a project.\\

\begingroup
\centering
\includegraphics[width=0.9\linewidth]{./appendix/assets/charts/Scale-up-vs-Scale-out.png}
\captionof{figure}{Scaling out vs scaling in}
~\label{fig:ScaleOutVsIn}
\endgroup
Note figure~\ref{fig:ScaleOutVsIn}, this is an example of vertical scaling (or scaling up) versus horizontal scaling (scaling out) for a file system. \\

\subsubsection{Solution}
\vspace{\vspaceconst}
As it turns out, micro services architecture, plus technologies such as Docker and Kubernetes solve this exact problem by having each feature/endpoint/verb/structure on a different service then vertically scaling each service when needed with a load balancer re-directing the traffic to instances.\\
In the long term this will also save on resources because developers will not need to spend as much time on writing code which can will take complete advantage of all of the computing resources available to it.\\

\subsection{The application}
\vspace{\vspaceconst}

When it comes to logging any sort of fitness activities, there is no standard, and there are a lot of different ways an individual or a trainer might log these activities; there simply does not exist a \textit{one size fits all solution} to this. It all just depends on the goals of said person or trainer. Because of this it is gets fairly complex when it comes to trying to make a digital form which could be filled out and be able to process and display all the data from it in any meaningful way. Usually different applications would create a rigid structure for the data then there would be forms to input the data in. For some people that would work perfectly, but not for all especially across athletes from different disciples of sport.\\

\begingroup
\centering
\begin{tabular}{l l p{3cm}}
  \toprule
  \# & Exercise & Sets \\ [0.5ex]
  \midrule
  1 & Squat & 10x40kg, 10x60kg, 8x70kg, 8x80kg\\
  \midrule
  2 & Dead lift & 12x50kg, 12x70kg, 10x80kg, 8x100kg\\
  \midrule
  3 & Hack squat & 15x50kg, 15x60kg, 15x70kg, 12x70kg\\
  \midrule
  4 & Leg press & 15x40kg, 15x60kg, 15x70kg, 15x80kg\\
  \midrule
  5 & Ham string curl & 15x26kg, 15x32kg, 15x36kg, 15x32kg\\
  \bottomrule
\end{tabular}
\captionof{table}{Simple workout log example}
~\label{table:WorkoutLogExample1}
\endgroup

For instance, one of the simplest logging types would be just performing straight sets of different exercises, some exercises being done with weights, or some other form of resistance which would also be noted down with every set. Table \ref{table:WorkoutLogExample1} shows one such example. However, as mentioned just now, it is a very simple form of logging and there are a lot more details that could be added, or a lot more variations that people could be doing which would need to be noted. Some examples are the following: \textit{super-setting}\footnote{Super-setting is performing a set of one exercise and another set of another exercise straight away without resting, then repeating the cycle.} and \textit{drop-setting}\footnote{Drop-setting is when the athlete performs another set without set at a smaller resistance, usually -20\%}. These are just some of the more common ones, however, not everyone will use these exercise techniques so not everyone will need to be able to log them. All of this adds extra complexity, which means an application for logging will either be very complex, or only useful to a subgroup of people with a specific workout style.


\subsubsection{Solution}
\vspace{\vspaceconst}
 
The premise to the solution in this project is quite simple, \textit{`keep it simple and stupid'}. The solution which is being proposed it to simplify the data structure as much as possible while still including some of the minimum features such as drop-sets, super-sets, notes, measurement units, etc. But also let the user create their own custom exercises which they will keep track of, reuse and then be able to look back on their history. As an extension to this system, the actual exercise data (as opposed to the meta-data that has just been discussed, such as data about each set, see table \ref{table:WorkoutLogExample1}, sets columns for an example) is variable in type as well. At the moment there are only two sub-types implemented, a usual \textit{set} type and a \textit{single value} type which just logs one single value per exercise. This lets users be able to better track things such as static holds\footnote{Static holds are experiences where you hold a position for a duration of time.}.\\
An example use case would be people which would like to keep track of their caffeine intake for every single workout. So there would be a custom exercise type with the measurement unit of \textit{mg} made by the user which would be called  `Caffeine' and would have a data type of \textit{single value}. Then on each workout that the user starts, they would have the option to log a point of exercise type `Caffeine' with the amount of caffeine ingested.\\
There was also an initial intention to create a really flexible report/charting analytical system for all of the data stored by the user. That system would be using tags as its base concept, and everything would be `tagable'. Then based on those tags, the user would be able to perform searches and compiling reports and cross referencing data on charts.\\
For example, a user would be able to tag a workout as a \textit{de-load workout}\footnote{A de-load workout is when the athlete uses lower weights as a form of rest but still workouts.} with a \textit{`\#de-load'} tag. Then, the user would want to generate a report or a chart which would show all of the workouts but miss out the ones where he de-loaded by creating a filter for not including this tag.\\
These tags could also be used as a way to define the different workout splits\footnote{A workout split meaning the different muscle groups the workout is targeting, e.g. \textit{Chest and back day}.} such as \textit{`\#chest'} and \textit{`\#back'} for a chest and back workout.\\
This concept could even be done on a finer scale on a per-exercise type basis. Give each exercise tags for each muscle or muscle groups they are working out, then be able to look up the exercise base on those tags.\\

\subsection{Methodology}
\vspace{\vspaceconst}
\NOTE~In this whole section I'm speaking from first person.\\

This project was mostly split into three main parts, the research phase, the setup phase, and the development phase. The research phase being especially important because I had no prior experience with such a micro services architecture. This was a completely new to me and I was not really sure what to expect. So I also had to be fairly flexible with my requirements because I was not sure what I could achieve and what I had to leave on the conceptual table. In the setup phase I had to setup the git repositories, an NPM library which was used as the shared code library amongst the projects, and a template which can be used for easier creation of extra services. Then, the last phase was actually split into multiple parts, the backend, the frontend and the testing and debugging phase.\\

\subsubsection{Milestones}
\begingroup
\centering
\begin{tabular}{l p{3.4cm} p{3.1cm}}
  \# & Milestone & Deadline\\
  \midrule
  1 & Research & Mid October to end of November\\
  2 & Setup & December\\
  3 & Backend development & January and February\\
  4 & Frontend development & March\\
  5 & Testing and troubleshooting & April\\
\end{tabular}
\captionof{table}{Mile Stone List}
\endgroup

When it came to adhering to the scheduled milestones I had set myself I have done mostly a pretty good job initially only slightly deviating and taking one week longer with the frontend development due to inexperience with the framework.\\
To split this down further, there were some mini milestones set for each micro service, of which there were 3: \textit{`fl-auth'}, \textit{`fl-tp-types'} and \textit{`fl-tp'}. With \textit{`fl-auth'} taking two weeks to complete, and the other two micro services taking 3 weeks each. Although, this is without why proper integration testing and troubleshooting. Some of that had to be done while building the frontend.\\

\subsubsection{Project management}
When it comes to integrated project management tools such as a Github Projects board or normal virtual Kanban board, I personally find them to be tiresome to use and usually result in more work to manage and keep track of them over time. In my opinion, they only come in useful when there are multiple contributors to a project or when the project scope is bigger than this project. However, here are some of the ways I managed my project.\\
First and foremost, I had a complete understanding about what the end goal of my project was, complete with an MVP and stretch goals. There was no need to have that broken down into individual stories for a backlog. So for the majority of the development, I only kept a to-do list in my personal journal. The only time when it was needed to start keeping track of stories was near the end when I started finding bugs, and came across small improvements I wanted to implement. This came in the form of a physical Kanban board with post it notes. I had an individual one for backend (refer to figure~\ref{fig:backendKanban}) and one for frontend (refer to figure~\ref{fig:frontendKanban}).\\

\begingroup
\centering
\includegraphics[width=0.9\linewidth]{./appendix/assets/img/backend_backlog.jpg}
\captionof{figure}{Backend Kanban Board}
~\label{fig:backendKanban}
\endgroup

\begingroup
\centering
\includegraphics[width=0.9\linewidth]{./appendix/assets/img/frontend_backlog.jpg}
\captionof{figure}{Frontend Kanban Board}
~\label{fig:frontendKanban}
\endgroup

This project's main client is myself, even though I am wanting to see if this can be taken to the market, this project is still make primarily for myself. For this reason, I precisely knew what the requirements and deliverables existed, so there was no need for an iterative approach to development. Meaning there was no need to agile sprint cycles.\\
The approach which I used was one of an \textit{`adaptive waterfall'} method. Meaning that I already had a good idea what the final product would look like and only made small adjustments in my plan as I would hit different milestones.\\

\NOTE\TODO~thats where i need some digitised stuff\\
- will also need to get some examples of my todo lists\\
- see if u can ask one of the guys to send u a picture of the requirements for the project that you have at home\\
- The research noes will also come in useful here\\

\TODO~need to figure out how the appendix works and how to reference stuff from there

\section{Design}
\vspace{\vspaceconst}

\begingroup
\centering
\includegraphics[width=0.7\linewidth]{./appendix/assets/charts/fitness-logger.jpg}
\captionof{figure}{Fitness Logger Architecture}
~\label{fig:flChart}
\endgroup

Even though micro services usually can increases the hugely complexity, this project stayed relatively simple. Figure~\ref{fig:flChart} shows a general diagram for this project which is largely made up of 3 parts, the client application, the docker container running an Nginx reverse proxy forwarding the traffic to the services,the docker containers running the services and the database management system, MongoDB in this case.\\

\subsection{Technological design}
\vspace{\vspaceconst}

\subsubsection{Database}
\vspace{\vspaceconst}

The database management system that was chosen for this project was MongoDB.\@ This is a document object storage database (aka No SQL db), meaning it stores JSON\footnote{JSON stands for JavaScript Object Notation and it is a data formatting standard used for sending data over networks, saving data to files and more.} objects which can potentially have a tree like structure, which is actually important to some of the data which the project will be storing. Other than MongoDB being able to store object trees another reason why it was chosen was because of its ease of use with virtually any programming language. For example, in NodeJS, a read operation would be just as simple as \textit{'collection.findOne({})'}, just providing a JSON or a BSON\footnote{BSON stands for Binary JSON which is just binary encoded JSON model.} object with the search parameters matching the field names in the database. A create operations is even simpler, \textit{`collection.insertOne(data)'}, with data being any kind of JSON serializeable object.\\

The alternative DBMS system which was considered for this project was Posture SQL. This is probably the best SQL system from a point of view of features and speed. However, the more considered it was the more it was realised that there is no point of using a relational database because the relations would have to be defines on the backend application side. That is because, if the different services where to interact with each other's database, or were all to use the same database, it could potentially case problems with data integrity on the database side. So, it is generally accepted as good practice that all micro services would have their own database, and if they needed to read or write data to another micro service's database, they would do it through their API.\@ Also, MongoDB offered the project the flexibility to use nested JSON objects which ended up being used in the \textit{`fl-tp'} service (see section \ref{sec:dataStruct}).

\subsubsection{Data structures}\label{sec:dataStruct}
\vspace{\vspaceconst}

As mentioned before, one way to solve the problem of workout logging which was stated was to be create simple data structure which could be used in flexible ways in conjunction with their own custom \tpts by the users of the application.\\
So, the current data structure design is split into three parts, \tps, \tgs and \tpts. \textit{`Tracking point types'} is the first data structure to have been made, it contains information about each individual custom exercise, or any other tracking point the user might want to create. Code snippet~\ref{code:tptStruct} is the data structure used inside the \textit{`fl-tp-type'}, it allows the user to define their own measurement units, in case the experience uses some arbitrary resistance values; and last but not least we have the data type, this is an enum which tells \textit{`fl-tp'} micro service what kind of data this type will store. At the moment there are only two types of data, however, this could be expanded in the future, and theoretically could even add user definable data types.\\

\begin{lstlisting}[escapeinside={(*}{*)}, label={code:tptStruct},caption={Tracking Point Types Data Struct}]
export enum DataType {
    Sets = 'sets',
    SingleValue = 'single-value',
}

/* ITrackingPointTypes interface for typescript. */
export interface ITrackingPointTypes {
    userId: string;
    tpName: string;
    description: string;
    dataType: DataType;
    measurementUnit: string;
}
\end{lstlisting}

The next data structure is one of the simplest ones, it is used to store meta data about each \tg (code snippet~\ref{code:tgStruct}). An example of a \tg could be one workout which would have multiple \tps. So a \tg would have meta data about start time, end time, and notes about the workout. The reason why there is no \tps inside this typescript interface. Note, the variable definition on line \ref{code:tgStruct:endTime} of snipped \ref{code:tpStruct} is of type \textit{`number $\vert$ undefined'} the reason for that is that when a \tg is first created it will not have an end time, so at first it is set to null.\\

\begin{lstlisting}[escapeinside={(*}{*)},label={code:tgStruct} ,caption={Tracking Group Struct}]
export interface TrackingGroup {
    userId: string;
    startTime: number;
    endTime: number | undefined; (*\label{code:tgStruct:endTime}*)
    notes: string;
}
\end{lstlisting}

The \tp data structure (code snipped \ref{code:tpStruct}) is the most important one, this is the actual structure for the exercise data or as it is referred to internally, \tps. It holds some meta data about the exercise but also the data of the exercise itself which, the type of that is retrieved from its corresponding \tg. This is part of what makes this system so flexible. A user is able to create their own type of workout, with potentially limitless types of data, then be able to log that kind of type of data into the database. Line \ref{code:tpStruct:dataTypes} of snippet \ref{code:tpStruct} is the way that the different data types are handled in the \textit{`fl-tp'} micro service. Here the two data structures are hard coded into the service, but technically with the right validation it should be easy and possible for the user to just use the typescript type of \textit{`any'}.\\

\begin{lstlisting}[escapeinside={(*}{*)},label={code:tpStruct} ,caption={Tracking Point Struct}]
export interface SingleValue {
    value: string;
}

export interface TpSet {
    reps: string;
    value: string;
    isDropset: boolean;
    setNr: number;
}

export interface TrackingPoint {
    userId: string;
    tpTypeId: string;
    tgId: string;
    notes: string;
    data: TpSet[] | SingleValue; (*\label{code:tpStruct:dataTypes}*)
    tpNr: number;
}
\end{lstlisting}

\subsubsection{Programming languages \& frameworks}
\vspace{\vspaceconst}

Another benefit, when it comes to using micro services, is the fact that a project could mix and mach programming languages,frameworks and stacks as needed throughout the codebase. Usually this is quite impractical, as it can often create more problems from a developmental point of view. However, there can be legitimate benefits for it. One such reason being using different programming languages as its strong point. For example, NodeJS\footnote{Node.js is a JavaScript runtime environment that runs on the V8 engine (same as Chrome) and executes JavaScript code outside a web browser. Designed for the backend.} could be used where there is a need of high I/O and Java could be used where there is a need for faster computation. And since micro services are deployed in containers which have their own pre-defined environments with the needed dependencies, problems that would arise from mixing different deployments on the same system are no more.\\
So as a proof of concept, It was decided that the first micro service to be developed would be done using a different programming language. The language chosen was Golang\footnote{Golang is a statically typed, compiled programming language designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson.} with the Echo\footnote{Echo is a web API framework developed for Golang.} framework, for the simple reason that this language is very powerful, offers a proper typing system, interfaces easily with MongoDB and it is really easy to develop and expose web API using it.\\
The default programming stack for this project is NodeJS with typescript\footnote{Typescript is a typing system for javascript run time environments} and express\footnote{Express is a popular NodeJS framework for creating web APIs}. For the database connection library \textit{mongoose} was used at first because of its popularity and the author's experience with it. However, for the last micro service, the base \textit{mongo} library was used because typescript already offers a typing system in form of interfaces, which is one of the problems that \textit{mongoose} fixes. So, in the author's opinion, using the base \textit{mongo} NodeJS library results in cleaner code.\\

\subsubsection{Micro service split}
\vspace{\vspaceconst}

It was decided that the micro services would be split largely by functionality and the designed data structures. For this reason it was originally designed with 4 micro services in mind (4 as the final product and 3 as the MVP): \textit{`fl-auth'} for authentication, \textit{`fl-tp-types'} for the custom user types, and \textit{`fl-tp'} for the \tgs and the \tps. However, \textit{`fl-tp'} could have actually been split down even more, one service for \tgs and another for \tps. At the time of designing, it it was just thought that these data structures are related enough that they could be in the same micro service. Which is still true, however, in practice they are just two different endpoint and could easily be split up with minimal work. The fourth micro service being \textit{`fl-analytics'}, a micro service for compiling reports and other analytical data based on the data structures used in the project.\\

\subsection{User Interface}
\vspace{\vspaceconst}
\TODO need to write this up\\
\NOTE~talk about loose designs of the ui i have

Since the author's main intention with this project was not the UI or overall user experience, this was further down the priority list. However, to aid the UI development a few sketches were made.

\section{Implementation and Testing}
\vspace{\vspaceconst}

\subsection{Setup}
\vspace{\vspaceconst}
This section will be talking about the different aspects of the setup phase: version control setup, shared code library, template creation and CI/CD.

\subsubsection{Version control}
\vspace{\vspaceconst}
The version control management software which has been chosen is Git on GitHub. Other than being simple, Git is also very powerful, specifically in this project, the git-sub module system has been used.  
\begin{quote}
  `Git submodules are simply a reference to another repository at a particular snapshot in time'\cite{atlasianGitSubmodule}
\end{quote}
Originally intended as a dependency tracking system. One project would have a git submodule of some library which exists on another git repository; in a user specified folder, that git repository would be then cloned and a snapshot of it at that current commit. The owner of the parent repository would then be able to use a specified version of the library in their own project as it would be cloned together with the main parent repository.\\
This essentially allows for git repositories to be nested inside one another for better structures. And in this project git submodules was used to separate each individual micro service and the shared code library out into their own repository and CI/CD environment. This separation of repositories is really nice when it comes to working on multiple independent or semi-independent projects that make up a bigger system which would ideally still have one big repository.\\
Consider this use case, each submodule repository has its own CI pipeline where on commits or merges tests and builds are triggered. However, when there is a milestone reached or a version increase, the team could then branch the project parent repository, perform the version bump and then have the CI/CD pipeline of the parent repository perform more builds and tests, here they would even do integration tests with the whole application and not just individually on a per submodule level. So even though all tests and builds pass on the individual submodule, where the team does not need to worry about accidentally triggering builds for the other projects, the new version could have broken something on the bigger project.\\

\subsubsection{Shared code library}
\vspace{\vspaceconst}
Since most of the micro services were written in NodeJS, an NPM\footnote{NPM or Node Package Manager is a package management system that allows one to pull in dependencies from repositories or make their own packages.} was made to share code in-between them. This was necessary because the micro services would be using a lot of the same code like JWT\footnote{JWT or JSON Web Token is an RFC standard for representing security claims\cite{jwtio}.} wrappers, database wrappers, environment variable definitions, data structures and more. Table~\ref{table:flSharedElements} showcases some of the more important elements of the \textit{`fl-shared'} library.\\

\begingroup
\centering
\begin{tabular}{p{2cm} p{5cm}}
  Env wrapper and definition & This has a type definition to tell node which environment variables will exist and provides a wrapper for dealing with env variables.\\
  FlApi & FlApi is a HTTP client which would make calls to neighbouring micro services.\\
  JwtWrapper & This contains helper functions for the JWT lib, but also has express authentication middleware which authorises the users.\\
  Logger & This is a simple std log library, but the idea is that it would be expanded to be able to log on message buses and more.\\
  Models & This is a collection of all the data structures which would be shared across the entire application.\\
\end{tabular}
\captionof{table}{\textit{Fl-shared} elements}
~\label{table:flSharedElements}
\endgroup

\subsubsection{Template for micro services}
\vspace{\vspaceconst}
With micro services it can be very useful to create a bare-bones project with some `hello world' implementation that will define the micro service structure and all of the basic always needed dependencies. This makes is easy to make sure that each project looks structurally similar since they all would start from the same bare-bones project. Additionally this makes the development of new micro services even easier to develop. Such a template was created for this project, however, it was not fully utilised because of several reasons.

\begingroup
\centering
\includegraphics[width=0.5\linewidth]{./appendix/assets/img/flTemplateTree.png}
\captionof{figure}{Fl-template folder structure}
~\label{fig:flTemplateTree}
\endgroup

\begingroup
\centering
\includegraphics[width=0.5\linewidth]{./appendix/assets/img/flTpTypesTree.png}
\captionof{figure}{Fl-tp-types folder structure}
~\label{fig:flTpTypesTree}
\endgroup

Figure~\ref{fig:flTemplateTree} shows a tree view of the micro service template. As you can see there are some key differences such as a unified clients folder, which would be used for any sort of clients the application would need. However, in addition to that, the kafka client was deleted. In the thought was in the beginning that kafka would be used for asynchronous calls, but in practice, at least for the MVP\footnote{MVP aka minimal viable product.}, there was no need for it so was later removed. Furthermore, the \textit{environment.d.ts} file was removed, the reason for that was the realisation that it was possible to define the environment typings inside the \textit{fl-shared} library.\\

\subsubsection{CI/CD}
\vspace{\vspaceconst}

\subsection{\textit{Fl-auth} service}
\vspace{\vspaceconst}
The \textit{fl-auth} service was the only service to be written in a different programming language, and as mentioned before, it was done so as a proof of concept simply because this was the simplest service to develop. It only has 3 endpoints.\\

\begingroup
\centering
\begin{tabular}{p{2.5cm} p{4.5cm}}
  POST /register & This accepts username, email and password. The password is the hashed with salted and hashed bcrypt\footnote{Bcrypt is a common password hashing function based on the Blowfish cipher.}, then stored in the MongoDB database.\\
  POST /login & This accepts email and password, then it checked the password against the hashed password stored int he database, if a match is made, a JWT token with the appropriate data is generated and sent back.\\
  POST /verify\_me & This accepts the JWT and checks its validity.\\
\end{tabular}
\captionof{table}{\textit{Fl-auth} endpoint}
~\label{table:flAuthEndpoints}
\endgroup

The \textit{`/verify\_me'} endpoint is not actually used. The plan was that it wold be used internally by the other micro services to validate a user's JWT token, however, it was realised that this is not actually needed as with the JWT secret\footnote{JWT secrets are used to generate and to deconstruct the JWT payloads.} it is possible to do that from the other micro services. Although, this endpoint was left in there for possible use by the client, it might even be modified so that it returns the roles which are stored inside it, so that the client is aware of the user's roles. This would be useful in case it is decided to add some form of admin user with admin actions.\\

At the moment authentication service is not actually feature complete. It lacks features such as password recovery proper admin control over the accounts, OAuth\footnote{OAuth\cite{oauth} is an open standard for access delegation, commonly used as a way for Internet users to grant websites or applications access to their information on other websites but without giving them the passwords. This mechanism is used by companies such as Amazon, Google, Facebook, Microsoft and Twitter to permit the users to share information about their accounts with third party applications or websites.} and more. However, it works well enough as a test MVP.\@ In a proper implementation, ideally a system such KeyCloack\cite{keycloack} or Auth0\cite{auth0}.\\

Currently the service generated a JWT based on a JWT claim structure (see code snippet \ref{code:jwtClaimGo}) which stores all the information about eh user, their email, username, user id and an array of roles the user holds.\\

\lstset{language=Golang}
\begin{lstlisting}[escapeinside={(*}{*)}, label={code:jwtClaimGo} ,caption={JWT Claim in Golang}]
type JwtClaim struct {
  ID       string   `json:"id"`
  Username string   `json:"username"`
  Email    string   `json:"email"`
  Roles    []string `json:"roles"`
  jwt.StandardClaims
}
\end{lstlisting}
\lstset{language=TypeScript}

See Section~\ref{section:innerServiceComms} to see how this system has been applied to authenticate communication in-between services.\\

\subsection{\textit{Fl-tp-types} service}
\vspace{\vspaceconst}
The \textit{fl-tp-types} micro service was the first service to be written in the default stack of NodeJS, typescript and express.  When it comes to the database client, in this service mongoose was used simply because the author was familiar with and the wide support on online forums. 
\NOTE however it is annoying to make both a typescript type and a mongoose type and managing those separately


\subsection{\textit{Fl-tp} service}
\vspace{\vspaceconst}

\subsection{Inner service communication}
\vspace{\vspaceconst}
~\label{section:innerServiceComms}

\NOTE~talk about jwt implementation with a different role for microservices
\NOTE~talk about how you have a http client in the shared code and how it contacts the rproxy, which is good design bc if that was also reposible for load balancing it would load balance, services need to be de-coupled as mch as possible

\subsection{Android client}
\vspace{\vspaceconst}

\subsubsection{API Client}
\vspace{\vspaceconst}

% \section{Evaluation}
% \vspace{\vspaceconst}

% \subsection{Usability}
% \vspace{\vspaceconst}

% \subsection{Other Criteria}
% \vspace{\vspaceconst}

% \section{Description of the Final Product}
% \vspace{\vspaceconst}

% \section{Reflection}
% \vspace{\vspaceconst}

% \section{Conclusion}
% \vspace{\vspaceconst}

% \section*{Acknowledgements}
% \vspace{\vspaceconst}

\newpage
\begin{thebibliography}{9}

  \bibitem{Docker}
  Docker (Software) Wikipedia (2021).\\
  \url{https://en.wikipedia.org/wiki/Docker_(software)}

  \bibitem{k8s}
  Kubernetes website (2021).\\
  \url{https://kubernetes.io/}

  \bibitem{grpc}
  gRPC website (2021).\\
  \url{https://www.grpc.io/}

  \bibitem{kafka}
  Kafka website (2021).\\
  \url{https://kafka.apache.org/}

  \bibitem{linkerd}
  Linkerd website (2021).\\
  \url{https://linkerd.io/}

  \bibitem{istio}
  Istio website (2021).\\
  \url{https://istio.io/}
  
  \bibitem{atlasianGitSubmodule}
  Git sub module documentation from Atlasian(2021).
  \url{https://www.atlassian.com/git/tutorials/git-submodule}
 
  \bibitem{jwtio}
  JWT.io website (2021).
  \url{https://www.jwt.io}

  \bibitem{auth0}
  Auth0 website (2021).
  \url{https://auth0.com/#!}

  \bibitem{keycloack}
  KeyCloack website (2021).
  \url{https://www.keycloak.org/}

  \bibitem{oauth}
  Oauth wiki page (2021).
  \url{https://en.wikipedia.org/wiki/OAuth}
\end{thebibliography}

\section*{Appendices}
\vspace{\vspaceconst}

\end{multicols}
\end{document}
